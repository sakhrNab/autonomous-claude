"""
Dynamic Capability Creator

This module enables the system to create new capabilities (agents, skills, hooks)
when it encounters tasks that don't match existing capabilities.

Features:
- Analyze task requirements
- Generate appropriate Python code
- Register new capabilities with Source of Truth
- Test the new capability
- Self-improve over time
"""

import asyncio
import json
import shutil
from pathlib import Path
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from datetime import datetime


@dataclass
class CapabilitySpec:
    """Specification for a new capability."""
    name: str
    type: str  # agent, skill, hook
    description: str
    triggers: List[str]
    inputs: Dict[str, str]  # name: type
    outputs: Dict[str, str]
    dependencies: List[str]
    code: str = ""


class CapabilityCreator:
    """
    Dynamic Capability Creator - generates new agents, skills, and hooks.

    When the system encounters a task without a matching capability,
    this creator analyzes the need and generates appropriate code.
    """

    def __init__(self):
        self.base_path = Path(__file__).parent.parent
        self.agents_path = self.base_path / "agents"
        self.skills_path = self.base_path / "skills"
        self.hooks_path = self.base_path / "hooks"
        self.templates_path = self.base_path / "templates"

        # Create directories
        for path in [self.agents_path, self.skills_path, self.hooks_path, self.templates_path]:
            path.mkdir(parents=True, exist_ok=True)

        # Claude CLI for code generation
        self.claude_cli = shutil.which("claude")

        # Store templates
        self._init_templates()

    def _init_templates(self):
        """Initialize capability templates."""
        self.templates = {
            "agent": '''"""
{name} Agent

{description}

Auto-generated by Capability Creator on {created_at}
"""

import asyncio
import json
from pathlib import Path
from typing import Dict, Any, Optional
from dataclasses import dataclass


@dataclass
class {class_name}Result:
    """Result from {name} agent."""
    success: bool
    output: Any
    error: Optional[str] = None


class {class_name}:
    """
    {description}

    Triggers: {triggers}
    """

    def __init__(self):
        self.name = "{name}"
        self.base_path = Path(__file__).parent.parent

    async def execute(self, task: str, context: Optional[Dict] = None) -> {class_name}Result:
        """
        Execute the agent's task.

        Args:
            task: The task description
            context: Optional context dictionary

        Returns:
            {class_name}Result with success status and output
        """
        try:
            # TODO: Implement agent logic
            {implementation}

            return {class_name}Result(
                success=True,
                output=result,
            )

        except Exception as e:
            return {class_name}Result(
                success=False,
                output=None,
                error=str(e),
            )


# Singleton
_instance: Optional[{class_name}] = None


def get_{snake_name}() -> {class_name}:
    """Get the singleton {name} agent."""
    global _instance
    if _instance is None:
        _instance = {class_name}()
    return _instance
''',

            "skill": '''"""
{name} Skill

{description}

Auto-generated by Capability Creator on {created_at}
"""

import asyncio
from pathlib import Path
from typing import Dict, Any, Optional
from dataclasses import dataclass


@dataclass
class {class_name}Result:
    """Result from {name} skill."""
    success: bool
    data: Any
    error: Optional[str] = None


class {class_name}:
    """
    {description}

    Triggers: {triggers}
    """

    def __init__(self):
        self.name = "{name}"

    async def execute(self, inputs: Dict[str, Any]) -> {class_name}Result:
        """
        Execute the skill.

        Args:
            inputs: Input parameters

        Returns:
            {class_name}Result with success status and data
        """
        try:
            # TODO: Implement skill logic
            {implementation}

            return {class_name}Result(
                success=True,
                data=result,
            )

        except Exception as e:
            return {class_name}Result(
                success=False,
                data=None,
                error=str(e),
            )


# Convenience function
async def {snake_name}(inputs: Dict[str, Any]) -> {class_name}Result:
    """Execute the {name} skill."""
    skill = {class_name}()
    return await skill.execute(inputs)
''',

            "hook": '''"""
{name} Hook

{description}

Auto-generated by Capability Creator on {created_at}
"""

from pathlib import Path
from typing import Dict, Any
from datetime import datetime

# Import from hook system
import sys
sys.path.insert(0, str(Path(__file__).parent.parent))
from hooks.hook_system import Hook, HookTrigger, HookResult


class {class_name}(Hook):
    """
    {description}

    Trigger: {trigger_type}
    Priority: {priority}
    """

    def __init__(self):
        super().__init__(
            name="{name}",
            trigger=HookTrigger.{trigger_type},
            priority={priority}
        )

    async def execute(self, context: Dict[str, Any]) -> HookResult:
        """
        Execute the hook.

        Args:
            context: Execution context

        Returns:
            HookResult with success status and output
        """
        start = datetime.now()

        try:
            # TODO: Implement hook logic
            {implementation}

            duration = int((datetime.now() - start).total_seconds() * 1000)
            return HookResult(
                hook_name=self.name,
                success=True,
                output=result,
                duration_ms=duration,
            )

        except Exception as e:
            return HookResult(
                hook_name=self.name,
                success=False,
                output=None,
                error=str(e),
            )
''',
        }

    async def analyze_need(self, task_description: str, existing_capabilities: List[str]) -> Optional[CapabilitySpec]:
        """
        Analyze a task and determine if a new capability is needed.

        Returns CapabilitySpec if a new capability should be created.
        """
        if not self.claude_cli:
            return None

        try:
            prompt = f"""Analyze this task and determine if we need a new capability.

TASK: {task_description}

EXISTING CAPABILITIES: {', '.join(existing_capabilities)}

If the task can be handled by existing capabilities, return:
{{"needs_new": false}}

If a new capability is needed, return:
{{
    "needs_new": true,
    "name": "capability-name",
    "type": "agent|skill|hook",
    "description": "What it does",
    "triggers": ["keyword1", "keyword2"],
    "inputs": {{"param1": "string", "param2": "int"}},
    "outputs": {{"result": "dict"}},
    "dependencies": ["dep1", "dep2"]
}}

JSON only:"""

            process = await asyncio.create_subprocess_exec(
                self.claude_cli,
                "-p", prompt,
                "--output-format", "text",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

            stdout, _ = await asyncio.wait_for(process.communicate(), timeout=30)
            output = stdout.decode("utf-8").strip()

            # Parse JSON
            import re
            json_match = re.search(r'\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}', output, re.DOTALL)
            if json_match:
                data = json.loads(json_match.group())

                if not data.get("needs_new", False):
                    return None

                return CapabilitySpec(
                    name=data.get("name", "new-capability"),
                    type=data.get("type", "skill"),
                    description=data.get("description", ""),
                    triggers=data.get("triggers", []),
                    inputs=data.get("inputs", {}),
                    outputs=data.get("outputs", {}),
                    dependencies=data.get("dependencies", []),
                )

        except Exception as e:
            print(f"Analysis error: {e}")

        return None

    async def create_capability(self, spec: CapabilitySpec) -> Dict[str, Any]:
        """
        Create a new capability based on the specification.

        Returns result with success status and file path.
        """
        try:
            # Generate implementation code
            implementation = await self._generate_implementation(spec)
            spec.code = implementation

            # Generate full code from template
            code = self._generate_code(spec)

            # Determine output path
            if spec.type == "agent":
                file_path = self.agents_path / f"{self._to_snake_case(spec.name)}.py"
            elif spec.type == "skill":
                file_path = self.skills_path / f"{self._to_snake_case(spec.name)}.py"
            elif spec.type == "hook":
                file_path = self.hooks_path / f"{self._to_snake_case(spec.name)}.py"
            else:
                return {"success": False, "error": f"Unknown type: {spec.type}"}

            # Write the file
            file_path.write_text(code)

            # Register with Source of Truth
            await self._register_capability(spec)

            return {
                "success": True,
                "file_path": str(file_path),
                "capability": spec.name,
                "type": spec.type,
            }

        except Exception as e:
            return {"success": False, "error": str(e)}

    async def _generate_implementation(self, spec: CapabilitySpec) -> str:
        """Generate the implementation code for a capability."""
        if not self.claude_cli:
            return "result = {'implemented': False, 'reason': 'Manual implementation required'}"

        try:
            prompt = f"""Generate Python implementation code for this capability:

NAME: {spec.name}
TYPE: {spec.type}
DESCRIPTION: {spec.description}
INPUTS: {json.dumps(spec.inputs)}
OUTPUTS: {json.dumps(spec.outputs)}

Generate ONLY the implementation code (the body of the execute method).
Do not include the function definition, just the code inside.
The code should set a 'result' variable with the output.

Use async/await if needed.
Handle errors appropriately.

Code only, no explanation:"""

            process = await asyncio.create_subprocess_exec(
                self.claude_cli,
                "-p", prompt,
                "--output-format", "text",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

            stdout, _ = await asyncio.wait_for(process.communicate(), timeout=60)
            output = stdout.decode("utf-8").strip()

            # Clean up output
            if output.startswith("```"):
                lines = output.split("\n")
                output = "\n".join(lines[1:-1] if lines[-1] == "```" else lines[1:])

            return output or "result = {'implemented': False}"

        except Exception:
            return "result = {'implemented': False, 'reason': 'Generation failed'}"

    def _generate_code(self, spec: CapabilitySpec) -> str:
        """Generate full code from template."""
        template = self.templates.get(spec.type, self.templates["skill"])

        # Convert name to various formats
        snake_name = self._to_snake_case(spec.name)
        class_name = self._to_class_name(spec.name)

        # Format implementation with proper indentation
        implementation = spec.code if spec.code else "result = {}"
        # Indent implementation
        implementation = "\n            ".join(implementation.split("\n"))

        # Determine hook-specific values
        trigger_type = "AFTER"  # default
        priority = 5

        if spec.type == "hook":
            if any(t in spec.triggers for t in ["before", "pre", "check"]):
                trigger_type = "BEFORE"
            elif any(t in spec.triggers for t in ["complete", "done", "finish"]):
                trigger_type = "ON_COMPLETE"
            elif any(t in spec.triggers for t in ["error", "fail"]):
                trigger_type = "ON_ERROR"

        return template.format(
            name=spec.name,
            snake_name=snake_name,
            class_name=class_name,
            description=spec.description,
            triggers=", ".join(spec.triggers),
            created_at=datetime.now().isoformat(),
            implementation=implementation,
            trigger_type=trigger_type,
            priority=priority,
        )

    async def _register_capability(self, spec: CapabilitySpec):
        """Register the new capability with Source of Truth."""
        try:
            from core.source_of_truth import get_source_of_truth, Capability, CapabilityType

            sot = get_source_of_truth()

            cap_type = {
                "agent": CapabilityType.AGENT,
                "skill": CapabilityType.SKILL,
                "hook": CapabilityType.HOOK,
            }.get(spec.type, CapabilityType.SKILL)

            capability = Capability(
                name=spec.name,
                type=cap_type,
                description=spec.description,
                triggers=spec.triggers,
                module_path=f"{spec.type}s.{self._to_snake_case(spec.name)}",
                dependencies=spec.dependencies,
            )

            sot.register_capability(capability)

        except Exception as e:
            print(f"Registration error: {e}")

    def _to_snake_case(self, name: str) -> str:
        """Convert name to snake_case."""
        # Replace hyphens and spaces with underscores
        name = name.replace("-", "_").replace(" ", "_")
        # Insert underscore before uppercase letters
        import re
        name = re.sub(r'(?<!^)(?=[A-Z])', '_', name)
        return name.lower()

    def _to_class_name(self, name: str) -> str:
        """Convert name to ClassName."""
        # Split on hyphens, underscores, spaces
        parts = name.replace("-", " ").replace("_", " ").split()
        return "".join(part.capitalize() for part in parts)

    async def improve_capability(self, capability_name: str, feedback: str) -> Dict[str, Any]:
        """
        Improve an existing capability based on feedback.
        """
        # Find the capability file
        for path in [self.agents_path, self.skills_path, self.hooks_path]:
            snake_name = self._to_snake_case(capability_name)
            file_path = path / f"{snake_name}.py"

            if file_path.exists():
                current_code = file_path.read_text()
                improved_code = await self._improve_code(current_code, feedback)

                if improved_code:
                    # Backup original
                    backup_path = file_path.with_suffix(".py.bak")
                    backup_path.write_text(current_code)

                    # Write improved
                    file_path.write_text(improved_code)

                    return {
                        "success": True,
                        "file_path": str(file_path),
                        "backup_path": str(backup_path),
                    }

        return {"success": False, "error": f"Capability {capability_name} not found"}

    async def _improve_code(self, current_code: str, feedback: str) -> Optional[str]:
        """Use Claude to improve existing code."""
        if not self.claude_cli:
            return None

        try:
            prompt = f"""Improve this code based on the feedback.

CURRENT CODE:
```python
{current_code}
```

FEEDBACK: {feedback}

Return the improved code. Keep the same structure but improve the implementation.
Return ONLY the Python code, no markdown formatting:"""

            process = await asyncio.create_subprocess_exec(
                self.claude_cli,
                "-p", prompt,
                "--output-format", "text",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

            stdout, _ = await asyncio.wait_for(process.communicate(), timeout=120)
            output = stdout.decode("utf-8").strip()

            # Clean markdown if present
            if output.startswith("```"):
                lines = output.split("\n")
                output = "\n".join(lines[1:-1] if lines[-1] == "```" else lines[1:])

            return output if output else None

        except Exception:
            return None


# Singleton
_creator: Optional[CapabilityCreator] = None


def get_capability_creator() -> CapabilityCreator:
    """Get the singleton Capability Creator."""
    global _creator
    if _creator is None:
        _creator = CapabilityCreator()
    return _creator


async def create_capability_for_task(task: str) -> Dict[str, Any]:
    """
    Convenience function to analyze a task and create a capability if needed.
    """
    from core.source_of_truth import get_source_of_truth

    creator = get_capability_creator()
    sot = get_source_of_truth()

    # Get existing capabilities
    existing = list(sot.capabilities.keys())

    # Analyze need
    spec = await creator.analyze_need(task, existing)

    if spec is None:
        return {"needed": False, "message": "Existing capabilities can handle this task"}

    # Create the capability
    result = await creator.create_capability(spec)
    result["needed"] = True

    return result
